<?php

/**
 * @name RouteBoxer
 * @version 1.0
 * @copyright (c) 2010 Google Inc.
 * @author Thor Mitchell
 * @transcription Justin Koreska
 * @link http://www.luktek.com/Blog/2011-02-03-google-maps-routeboxer-in-php The
 * source of this file from the internet.
 *
 * @fileoverview The RouteBoxer class takes a path, such as the Polyline for a
 * route generated by a Directions request, and generates a set of LatLngBounds
 * objects that are guaranteed to contain every point within a given distance
 * of that route. These LatLngBounds objects can then be used to generate
 * requests to spatial search services that support bounds filtering (such as
 * the Google Maps Data API) in order to implement search along a route.
 * <br/><br/>
 * RouteBoxer overlays a grid of the specified size on the route, identifies
 * every grid cell that the route passes through, and generates a set of bounds
 * that cover all of these cells, and their nearest neighbours. Consequently
 * the bounds returned will extend up to ~3x the specified distance from the
 * route in places.
 */

/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License. 
 */

class RouteBoxer
{
	// earth's mean radius in km
	const R = 6371;
	
	// Two dimensional array representing the cells in the grid overlaid on the path
	private $_grid;
	// Array that holds the latitude coordinate of each vertical grid line
	private $_latGrid = array();
	// Array that holds the longitude coordinate of each horizontal grid line
	private $_lngGrid = array();
	// Array of bounds that cover the whole route formed by merging cells that
	//  the route intersects first horizontally, and then vertically
	private $_boxesX = array();
	// Array of bounds that cover the whole route formed by merging cells that
	//  the route intersects first vertically, and then horizontally
	private $_boxesY = array();
	
	/**
	 * Generates boxes for a given route and distance
	 *
	 * @param {google.maps.LatLng[] | google.maps.Polyline} path The path along
	 *           which to create boxes. The path object can be either an Array of
	 *           google.maps.LatLng objects or a Maps API v2 or Maps API v3
	 *           google.maps.Polyline object.
	 * @param {Number} range The distance in kms around the route that the generated
	 *           boxes must cover.
	 * @return {google.maps.LatLngBounds[]} An array of boxes that covers the whole
	 *           path.
	 */
	public function box($vertices, $range)
	{
		// Build the grid that is overlaid on the route
		$this->_buildGrid($vertices, $range);
		// Identify the grid cells that the route intersects
		$this->_findIntersectingCells($vertices);
		// Merge adjacent intersected grid cells (and their neighbours) into two sets
		//  of bounds, both of which cover them completely
		$this->_mergeIntersectingCells();
		
		// Return the set of merged bounds that has the fewest elements
		return
			count($this->_boxesX) <= count($this->_boxesY) ?
			$this->_boxesX :
			$this->_boxesY ;
	}
	
	/**
	 * Generates boxes for a given route and distance
	 *
	 * @param {LatLng[]} vertices The vertices of the path over which to lay the grid
	 * @param {Number} range The spacing of the grid cells.
	 */
	function _buildGrid($vertices, $range)
	{
		// Create a LatLngBounds object that contains the whole path
		$routeBounds = new LatLngBounds();
		foreach ($vertices as $vertex)
		{
			$routeBounds->extend($vertex);
		}
		
		// Find the center of the bounding box of the path
		$routeBoundsCenter = $routeBounds->getCenter();
		
		// Starting from the center define grid lines outwards vertically until they
		//  extend beyond the edge of the bounding box by more than one cell
		array_push($this->_latGrid, $routeBoundsCenter->lat());
		
		// Add lines from the center out to the north
		array_push($this->_latGrid, $routeBoundsCenter->rhumbDestinationPoint(0, $range)->lat());
		for ($i = 2; $this->_latGrid[$i - 2] < $routeBounds->getNorthEast()->lat(); $i++)
		{
			array_push($this->_latGrid, $routeBoundsCenter->rhumbDestinationPoint(0, $range * $i)->lat());
		}
		
		// Add lines from the center out to the south
		for ($i = 1; $this->_latGrid[1] > $routeBounds->getSouthWest()->lat(); $i++)
		{
			array_unshift($this->_latGrid, $routeBoundsCenter->rhumbDestinationPoint(180, $range * $i)->lat());
		}
		
		// Starting from the center define grid lines outwards horizontally until they
		//  extend beyond the edge of the bounding box by more than one cell
		array_push($this->_lngGrid, $routeBoundsCenter->lng());
		
		// Add lines from the center out to the east
		array_push($this->_lngGrid, $routeBoundsCenter->rhumbDestinationPoint(90, $range)->lng());
		for ($i = 2; $this->_lngGrid[$i - 2] < $routeBounds->getNorthEast()->lng(); $i++)
		{
			array_push($this->_lngGrid, $routeBoundsCenter->rhumbDestinationPoint(90, $range * $i)->lng());
		}
		
		// Add lines from the center out to the west
		for ($i = 1; $this->_lngGrid[1] > $routeBounds->getSouthWest()->lng(); $i++)
		{
			array_unshift($this->_lngGrid, $routeBoundsCenter->rhumbDestinationPoint(270, $range * $i)->lng());
		}
		
		// Create a two dimensional array representing this grid
		$this->_grid = array_fill(0, count($this->_lngGrid), null);
		for ($i = 0; $i < count($this->_grid); $i++)
		{
			$this->_grid[$i] = array_fill(0, count($this->_latGrid), null);
		}
	}
	
	/**
	 * Find all of the cells in the overlaid grid that the path intersects
	 *
	 * @param {LatLng[]} vertices The vertices of the path
	 */
	function _findIntersectingCells($vertices)
	{
		// Find the cell where the path begins
		$hintXY = $this->_getCellCoords($vertices[0]);
		
		// Mark that cell and it's neighbours for inclusion in the boxes
		$this->_markCell($hintXY);
		
		// Work through each vertex on the path identifying which grid cell it is in
		for ($i = 1; $i < count($vertices); $i++)
		{
			// Use the known cell of the previous vertex to help find the cell of this vertex
			$gridXY = $this->_getGridCoordsFromHint($vertices[$i], $vertices[$i - 1], $hintXY);
			
			if ($gridXY[0] == $hintXY[0] && $gridXY[1] == $hintXY[1])
			{
				// This vertex is in the same cell as the previous vertex
				// The cell will already have been marked for inclusion in the boxes
				continue;
			}
			else if ((abs($hintXY[0] - $gridXY[0]) == 1 && $hintXY[1] == $gridXY[1]) ||
				($hintXY[0] == $gridXY[0] && abs($hintXY[1] - $gridXY[1]) == 1))
			{
				// This vertex is in a cell that shares an edge with the previous cell
				// Mark this cell and it's neighbours for inclusion in the boxes
				$this->_markCell($gridXY);
			}
			else
			{
				// This vertex is in a cell that does not share an edge with the previous
				//  cell. This means that the path passes through other cells between
				//  this vertex and the previous vertex, and we must determine which cells
				//  it passes through
				$this->_getGridIntersects($vertices[$i - 1], $vertices[$i], $hintXY, $gridXY);
			}
			
			// Use this cell to find and compare with the next one
			$hintXY = $gridXY;
		}
	}
	
	/**
	 * Find the cell a path vertex is in by brute force iteration over the grid
	 *
	 * @param {LatLng[]} latlng The latlng of the vertex
	 * @return {Number[][]} The cell coordinates of this vertex in the grid
	 */ 
	function _getCellCoords($latlng)
	{
		for ($x = 0; $this->_lngGrid[$x] < $latlng->lng(); $x++) {}
		for ($y = 0; $this->_latGrid[$y] < $latlng->lat(); $y++) {}
		
		return array($x - 1, $y - 1);
	}
	
	/**
	 * Find the cell a path vertex is in based on the known location of a nearby
	 *  vertex. This saves searching the whole grid when working through vertices
	 *  on the polyline that are likely to be in close proximity to each other.
	 *
	 * @param {LatLng[]} latlng The latlng of the vertex to locate in the grid
	 * @param {LatLng[]} hintlatlng The latlng of the vertex with a known location
	 * @param {Number[]} hint The cell containing the vertex with a known location
	 * @return {Number[]} The cell coordinates of the vertex to locate in the grid
	 */
	function _getGridCoordsFromHint($latlng, $hintlatlng, $hint)
	{
		if ($latlng->lng() > $hintlatlng->lng())
		{
			for ($x = $hint[0]; $this->_lngGrid[$x + 1] < $latlng->lng(); $x++) {}
		}
		else
		{
			for ($x = $hint[0]; $this->_lngGrid[$x] > $latlng->lng(); $x--) {}
		}

		if ($latlng->lat() > $hintlatlng->lat())
		{
			for ($y = $hint[1]; $this->_latGrid[$y + 1] < $latlng->lat(); $y++) {}
		}
		else
		{
			for ($y = $hint[1]; $this->_latGrid[$y] > $latlng->lat(); $y--) {}
		}
		
		return array($x, $y);
	}
	
	/**
	 * Identify the grid squares that a path segment between two vertices
	 * intersects with by:
	 * 1. Finding the bearing between the start and end of the segment
	 * 2. Using the delta between the lat of the start and the lat of each
	 *    latGrid boundary to find the distance to each latGrid boundary
	 * 3. Finding the lng of the intersection of the line with each latGrid
	 *     boundary using the distance to the intersection and bearing of the line
	 * 4. Determining the x-coord on the grid of the point of intersection
	 * 5. Filling in all squares between the x-coord of the previous intersection
	 *     (or start) and the current one (or end) at the current y coordinate,
	 *     which is known for the grid line being intersected
	 *     
	 * @param {LatLng} start The latlng of the vertex at the start of the segment
	 * @param {LatLng} end The latlng of the vertex at the end of the segment
	 * @param {Number[]} startXY The cell containing the start vertex
	 * @param {Number[]} endXY The cell containing the vend vertex
	 */ 
	function _getGridIntersects($start, $end, $startXY, $endXY)
	{
		// Step 1.
		$bearing = $start->rhumbBearingTo($end);
		
		$hint = $start;
		$hintXY = $startXY;
		
		// Handle a line segment that travels south first
		if ($end->lat() > $start->lat())
		{
			// Iterate over the east to west grid lines between the start and end cells
			for ($i = $startXY[1] + 1; $i <= $endXY[1]; $i++)
			{
				// Find the latlng of the point where the path segment intersects with
				//  this grid line (Step 2 & 3)
				$edgePoint = $this->_getGridIntersect($start, $bearing, $this->_latGrid[$i]);
				
				// Find the cell containing this intersect point (Step 4)
				$edgeXY = $this->_getGridCoordsFromHint($edgePoint, $hint, $hintXY);
				
				// Mark every cell the path has crossed between this grid and the start,
				//   or the previous east to west grid line it crossed (Step 5)
				$this->_fillInGridSquares($hintXY[0], $edgeXY[0], $i - 1);
				
				// Use the point where it crossed this grid line as the reference for the
				//  next iteration
				$hint = $edgePoint;
				$hintXY = $edgeXY;
			}
			
			// Mark every cell the path has crossed between the last east to west grid
			//  line it crossed and the end (Step 5)
			$this->_fillInGridSquares($hintXY[0], $endXY[0], $i - 1);
		}
		else
		{
			// Iterate over the east to west grid lines between the start and end cells
			for ($i = $startXY[1]; $i > $endXY[1]; $i--)
			{
				// Find the latlng of the point where the path segment intersects with
				//  this grid line (Step 2 & 3)
				$edgePoint = $this->_getGridIntersect($start, $bearing, $this->_latGrid[$i]);
				
				// Find the cell containing this intersect point (Step 4)
				$edgeXY = $this->_getGridCoordsFromHint($edgePoint, $hint, $hintXY);
				
				// Mark every cell the path has crossed between this grid and the start,
				//   or the previous east to west grid line it crossed (Step 5)
				$this->_fillInGridSquares($hintXY[0], $edgeXY[0], $i);
				
				// Use the point where it crossed this grid line as the reference for the
				//  next iteration
				$hint = $edgePoint;
				$hintXY = $edgeXY;
			}
			
			// Mark every cell the path has crossed between the last east to west grid
			//  line it crossed and the end (Step 5)
			$this->_fillInGridSquares($hintXY[0], $endXY[0], $i);
		}
	}
	
	/**
	 * Find the latlng at which a path segment intersects with a given
	 *   line of latitude
	 *     
	 * @param {LatLng} start The vertex at the start of the path segment
	 * @param {Number} brng The bearing of the line from start to end
	 * @param {Number} gridLineLat The latitude of the grid line being intersected
	 * @return {LatLng} The latlng of the point where the path segment intersects
	 *                    the grid line
	 */ 
	function _getGridIntersect($start, $bearing, $gridLineLat)
	{
		$d = $this::R * ((deg2rad($gridLineLat) - deg2rad($start->lat())) / cos(deg2rad($bearing)));
		return $start->rhumbDestinationPoint($bearing, $d);
	}
	
	/**
	 * Mark all cells in a given row of the grid that lie between two columns
	 *   for inclusion in the boxes
	 *     
	 * @param {Number} startx The first column to include
	 * @param {Number} endx The last column to include
	 * @param {Number} y The row of the cells to include
	 */ 
	function _fillInGridSquares($startx, $endx, $y)
	{
		if ($startx < $endx)
		{
			for ($x = $startx; $x <= $endx; $x++)
			{
				$this->_markCell(array($x, $y));
			}
		}
		else
		{
			for ($x = $startx; $x >= $endx; $x--)
			{
				$this->_markCell(array($x, $y));
			}
		}
	}
	
	/**
	 * Mark a cell and the 8 immediate neighbours for inclusion in the boxes
	 *     
	 * @param {Number[]} square The cell to mark
	 */ 
	function _markCell($cell)
	{
		$x = $cell[0];
		$y = $cell[1];
		$this->_grid[$x - 1][$y - 1] = 1;
		$this->_grid[$x][$y - 1] = 1;
		$this->_grid[$x + 1][$y - 1] = 1;
		$this->_grid[$x - 1][$y] = 1;
		$this->_grid[$x][$y] = 1;
		$this->_grid[$x + 1][$y] = 1;
		$this->_grid[$x - 1][$y + 1] = 1;
		$this->_grid[$x][$y + 1] = 1;
		$this->_grid[$x + 1][$y + 1] = 1;
	}
	
	/**
	 * Create two sets of bounding boxes, both of which cover all of the cells that
	 *   have been marked for inclusion.
	 *
	 * The first set is created by combining adjacent cells in the same column into
	 *   a set of vertical rectangular boxes, and then combining boxes of the same
	 *   height that are adjacent horizontally.
	 *
	 * The second set is created by combining adjacent cells in the same row into
	 *   a set of horizontal rectangular boxes, and then combining boxes of the same
	 *   width that are adjacent vertically.
	 *     
	 */ 
	function _mergeIntersectingCells()
	{
		// The box we are currently expanding with new cells
		$currentBox = null;
		
		// Traverse the grid a row at a time
		for ($y = 0; $y < count($this->_grid[0]); $y++)
		{
			for ($x = 0; $x < count($this->_grid); $x++)
			{
				if (null != $this->_grid[$x][$y])
				{
					// This cell is marked for inclusion. If the previous cell in this
					//   row was also marked for inclusion, merge this cell into it's box.
					// Otherwise start a new box.
					$box = $this->_getCellBounds(array($x, $y));
					if (null != $currentBox)
					{
						$currentBox->extend($box->getNorthEast());
					}
					else
					{
						$currentBox = $box;
					}
				}
				else
				{
					// This cell is not marked for inclusion. If the previous cell was
					//  marked for inclusion, merge it's box with a box that spans the same
					//  columns from the row below if possible.
					$this->_mergeBoxesY($currentBox);
					$currentBox = null;
				}
			}
			// If the last cell was marked for inclusion, merge it's box with a matching
			//  box from the row below if possible.
			$this->_mergeBoxesY($currentBox);
			$currentBox = null;
		}
		
		// Traverse the grid a column at a time
		for ($x = 0; $x < count($this->_grid); $x++)
		{
			for ($y = 0; $y < count($this->_grid[0]); $y++)
			{
				if (null != $this->_grid[$x][$y])
				{
					// This cell is marked for inclusion. If the previous cell in this
					//   column was also marked for inclusion, merge this cell into it's box.
					// Otherwise start a new box.
					$box = $this->_getCellBounds(array($x, $y));
					if (null != $currentBox)
					{
						$currentBox->extend($box->getNorthEast());
					}
					else
					{
						$currentBox = $box;
					}
				}
				else
				{
					// This cell is not marked for inclusion. If the previous cell was
					//  marked for inclusion, merge it's box with a box that spans the same
					//  rows from the column to the left if possible.
					$this->_mergeBoxesX($currentBox);
					$currentBox = null;
				}
			}
			// If the last cell was marked for inclusion, merge it's box with a matching
			//  box from the column to the left if possible.
			$this->_mergeBoxesX($currentBox);
			$currentBox = null;
		}

	}
	
	/**
	 * Search for an existing box in an adjacent row to the given box that spans the
	 * same set of columns and if one is found merge the given box into it. If one
	 * is not found, append this box to the list of existing boxes.
	 *
	 * @param {LatLngBounds}  The box to merge
	 */ 
	function _mergeBoxesX($box)
	{
		if (null != $box)
		{
			for ($i = 0; $i < count($this->_boxesX); $i++)
			{
				if ($this->_boxesX[$i]->getNorthEast()->lng() == $box->getSouthWest()->lng() &&
					$this->_boxesX[$i]->getSouthWest()->lat() == $box->getSouthWest()->lat() &&
					$this->_boxesX[$i]->getNorthEast()->lat() == $box->getNorthEast()->lat())
				{
					$this->_boxesX[$i]->extend($box->getNorthEast());
					return;
				}
			}
			array_push($this->_boxesX, $box);
		}
	}
	
	/**
	 * Search for an existing box in an adjacent column to the given box that spans
	 * the same set of rows and if one is found merge the given box into it. If one
	 * is not found, append this box to the list of existing boxes.
	 *
	 * @param {LatLngBounds}  The box to merge
	 */ 
	function _mergeBoxesY($box)
	{
		if (null != $box)
		{
			for ($i = 0; $i < count($this->_boxesY); $i++)
			{
				if ($this->_boxesY[$i]->getNorthEast()->lat() == $box->getSouthWest()->lat() &&
					$this->_boxesY[$i]->getSouthWest()->lng() == $box->getSouthWest()->lng() &&
					$this->_boxesY[$i]->getNorthEast()->lng() == $box->getNorthEast()->lng())
				{
					$this->_boxesY[$i]->extend($box->getNorthEast());
					return;
				}
			}
			array_push($this->_boxesY, $box);
		}
	}
	
	/**
	 * Obtain the LatLng of the origin of a cell on the grid
	 *
	 * @param {Number[]} cell The cell to lookup.
	 * @return {LatLng} The latlng of the origin of the cell.
	 */ 
	function _getCellBounds($cell)
	{
		return
			new LatLngBounds(
				new LatLng($this->_latGrid[$cell[1]], $this->_lngGrid[$cell[0]]),
				new LatLng($this->_latGrid[$cell[1] + 1], $this->_lngGrid[$cell[0] + 1])
			);
	}
	
}

class LatLng
{
	private $_lat;
	private $_lng;
	
	function __construct($lat, $lng)
	{
		$this->_lat = $lat;
		$this->_lng = $lng;
	}
	
        /**
         * Gets the latitude of the point
         * @return Double The latitude
         */
	public function lat()
	{
		return $this->_lat;
	}
	
        /**
         * Gets the longitude of the point
         * @return Double The longitude
         */
	public function lng()
	{
		return $this->_lng;
	}
	
	/* Based on the Latitude/longitude spherical geodesy formulae & scripts
	   at http://www.movable-type.co.uk/scripts/latlong.html
	   (c) Chris Veness 2002-2010
	*/ 
	public function rhumbDestinationPoint($bearing, $distance)
	{
		$R = 6371;
		$d = $distance / $R;
		$lat = deg2rad($this->lat());
		$lng = deg2rad($this->lng());
		$bearing = deg2rad($bearing);
		
		$lat2 = $lat + $d * cos($bearing);
		$dLat = $lat2 - $lat;
		$dPhi = log(tan($lat2 / 2 + pi() / 4) / tan($lat / 2 + pi() / 4));
		$q = (abs($dLat) > 0.0000000001) ? $dLat / $dPhi : cos($lat);
		$dLng = $d * sin($bearing) / $q;
		if (abs($lat2) > pi() / 2)
			$lat2 = $lat2 > 0 ? pi() - $lat2 : -(pi() - $lat2);
		$lng2 = fmod(($lng + $dLng + pi()), (2 * pi())) - pi();
		
		if (is_nan($lat2) or is_nan($lng2))
			return null;
		
		return
			new LatLng(rad2deg($lat2), rad2deg($lng2));
	}
	
	public function rhumbBearingTo($dest)
	{
		$dLng = deg2rad($dest->lng() - $this->lng());
		$dPhi = log(tan(deg2rad($dest->lat()) / 2 + pi() / 4) / tan(deg2rad($this->lat()) / 2 + pi() / 4));
		if (abs($dLng) > pi())
			$dLng = $dLng > 0 ? -(2 * pi() - $dLng) : (2 * pi() + $dLng);
		
		return
			$this->toBearing(atan2($dLng, $dPhi));
	}
	
	public function toBearing($bearing)
	{
		return fmod(rad2deg($bearing) + 360, 360);
	}
	
}

class LatLngBounds
{
	private $_NE;
	private $_SW;
	
	function __construct($sw = null, $ne = null)
	{
		if (null == $ne) $ne = new LatLng(-180, -180);
		if (null == $sw) $sw = new LatLng(180, 180);
		
		$this->_NE = $ne;
		$this->_SW = $sw;
	}
	
        /**
         * Gets the north east corner of the box
         * @return LatLng The north east corner
         */
	public function getNorthEast()
	{
		return $this->_NE;
	}
	
        /**
         * Gets the south west corner of the box
         * @return LatLng The south west corner
         */
	public function getSouthWest()
	{
		return $this->_SW;
	}
	
	public function extend($latlng)
	{
		$neLat = $this->_NE->lat();
		$neLng = $this->_NE->lng();
		$swLat = $this->_SW->lat();
		$swLng = $this->_SW->lng();
		
		if ($latlng->lat() > $neLat) $neLat = $latlng->lat();
		if ($latlng->lng() > $neLng) $neLng = $latlng->lng();
		if ($latlng->lat() < $swLat) $swLat = $latlng->lat();
		if ($latlng->lng() < $swLng) $swLng = $latlng->lng();
		
		$this->_NE = new LatLng($neLat, $neLng);
		$this->_SW = new LatLng($swLat, $swLng);
	}
	
        /**
         * Gets the center point of the box
         * @return \LatLng The center point
         */
	public function getCenter()
	{
		$lat = $this->_SW->lat() + ($this->_NE->lat() - $this->_SW->lat()) / 2;
		$lng = $this->_SW->lng() + ($this->_NE->lng() - $this->_SW->lng()) / 2;
		
		return
			new LatLng($lat, $lng);
	}

}

?>