<?php

/**
 * PassengersTable
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 */
class PassengersTable extends Doctrine_Table
{
    /**
     * Returns an instance of this class.
     * @return object PassengersTable
     */
    public static function getInstance()
    {
        return Doctrine_Core::getTable('Passengers');
    }

    /**
     * Gets all passengers with profiles
     * @return Doctrine_Collection The passengers with profiles 
     */
    public function getWithProfiles()
    {
        $q = $this->createQuery('pa')
          ->leftJoin('pa.People p')
          ->leftJoin('p.Profiles pr');;

        return $q->execute();
    }
    
    /**
     * Returns all passenger record for the authenticated user
     * @return Doctrine_Collection Returns a passengers collection for the user
     */
    public function getMyPassengers()
    {
        // Create the return value
        $passengers = null;

        if (sfContext::getInstance()->getUser()->isAuthenticated())
        {
            // Get the authenticated user's personId
            $myId = sfContext::getInstance()->getUser()->getGuardUser()->getPersonId();
            $passengers = $this->getPassengersForPerson($myId);
        }

        return $passengers;
    }

    /**
     * Returns all passenger records for a person
     * @param int $personId The person to get the passengers for
     * @param bool $includePastItems Whether to include carpools with a 
     * start_date before today in the results
     * @return Doctrine_Collection Returns a Passengers collection
     */
    public function getPassengersForPerson($personId, $includePastItems = false)
    {
        $q = $this->createQuery('pa')
          ->innerJoin('pa.Routes r')
          ->where('pa.person_id = ?', array($personId));
        if (!$includePastItems)
        {
            // Add the current passenger where clause to the query to prevent old 
            // carpools from being returned
            $q = $this->addCurrentRidesFilter($q);
        }
        
        // Order the rides by start date
        $q = $this->addOrderByStartDate($q);

        return $q->execute();
    }
    
    /**
     * Adds a where clause to a query to only return rides occuring today or in
     * the future
     * @param Doctrine_Query $query The query
     * @return Doctrine_Query The query with a current rides where clause 
     */
    public function addCurrentRidesFilter($query)
    {
        // Add a where clause to the query to only return carpools today or in
        // the future. Start date = null is valid because
        // it represents an open ended ride.
        return $query->andWhere('(pa.start_date >= ? OR pa.start_date IS NULL)', date('Y-m-d'))
                     ->andWhere('pa.status_id != ?', RideStatuses::$statuses[RideStatuses::RIDE_DELETED])
                     ->andWhere('pa.status_id != ?', RideStatuses::$statuses[RideStatuses::RIDE_CLOSED]);
    }
    
    /**
     * Adds an order by clause to a query to sort the rides by date
     * @param Doctrine_Query $query The query
     * @return Doctrine_Query The query with the order by start_date clause 
     */
    public function addOrderByStartDate($query)
    {
        // Add the order by clause
        return $query->orderBy('pa.start_date');
    }
    
    /**
     * Returns passengers that are within $distance of the origin and destination
     * coordinates and optionally on a specified date.
     *
     * @param        float $distance The distance to search within
     * @param        float $originLatitude The latitude of the origin
     * @param        float $originLongitude The longitude of the origin
     * @param        float $destinationLatitude The latitude of the destination
     * @param        float $destinationLongitude The longitude of the destination
     * @param        string $date The date to search on
     *
     * @return Doctrine_Collection Returns a Passengers collection with profiles
     * and people included
     */
    public function getNearPoints ($distance,
                                   $originLatitude = null,
                                   $originLongitude =null,
                                   $destinationLatitude = null,
                                   $destinationLongitude = null,
                                   $date = null)
    {
        // TODO: Make the query detect order of locations
        // Use a query similar to the following
        // SELECT * FROM carpools c
        // INNER JOIN routes r
        // ON c.route_id = r.route_id
        // WHERE EXISTS
        // (
        //         SELECT *,  MIN(DISTANCE($origin->getLatitude(), $origin->getLongitude(), o.latitude, o.longitude)) as start_distance
        //         FROM locations o
        //         INNER JOIN  steps os
        //         ON os.step_id = o.step_id
        //         INNER JOIN  legs ole
        //         ON ole.leg_id = os.leg_id
        //         INNER JOIN routes oro
        //         ON oro.route_id = ole.route_id
        //         GROUP BY oro.route_id
        //         HAVING start_distance < $distance
        //           AND r.route_id = oro.route_id
        // )
        // AND EXISTS (
        //         SELECT *,  MIN(DISTANCE($destination->getLatitude(), $destination->getLongitude, d.latitude, d.longitude)) as end_distance
        //         FROM locations d
        //         INNER JOIN  steps ds
        //         ON ds.step_id = d.step_id
        //         INNER JOIN  legs dle
        //         ON dle.leg_id = ds.leg_id
        //         INNER JOIN routes dro
        //         ON dro.route_id = dle.route_id
        //         GROUP BY dro.route_id
        //         HAVING end_distance < $distance
        //           AND r.route_id = dro.route_id
        // );
        // Use a raw sql query because the relationship enforcement is less
        $q = new Doctrine_RawSql();
        // Curly braces are needed for component hydration
        $q->select('{pa.*}, {r.*}, {pe.*}, {pr.*}');
        $q->from('passengers pa');
        $q->innerJoin('routes r ON pa.solo_route_id = r.route_id');
        $q->innerJoin('people pe ON pa.person_id = pe.person_id');
        $q->innerJoin('profiles pr ON pr.person_id = pe.person_id');
        // See if we need to add a where clause for the origin location
        if ($originLatitude != null && $originLongitude != null){
            // Add the where clause that searchs for routes near the start
            // location. Need to add a bounding box where clause to sub clause
            // to improve performance
//            $q->andWhere('EXISTS (
//                 SELECT *,  MIN(DISTANCE(?, ?, o.latitude, o.longitude)) as start_distance
//                 FROM locations o
//                 INNER JOIN  steps os
//                 ON os.step_id = o.step_id
//                 INNER JOIN  legs ole
//                 ON ole.leg_id = os.leg_id
//                 INNER JOIN routes oro
//                 ON oro.route_id = ole.route_id
//                 GROUP BY oro.route_id
//                 HAVING start_distance < ?
//                   AND r.route_id = oro.route_id
//                 )', array($originLatitude,
//                            $originLongitude,
//                            $distance));
            // Use bounding box search for now for performancelp speed up the queries
            // Get the bounding boxes to help speed up the queries
            $originBoundingBox = Locations::getBoundingBox($originLatitude, 
                                                           $originLongitude, 
                                                           $distance);
            $originBoxMinLatitude = $originBoundingBox['minLatitude'];
            $originBoxMaxLatitude = $originBoundingBox['maxLatitude'];
            $originBoxMinLongitude = $originBoundingBox['minLongitude'];
            $originBoxMaxLongitude = $originBoundingBox['maxLongitude'];
            
            $q->andWhere('EXISTS (
                 SELECT *
                 FROM locations o
                 INNER JOIN  steps os
                 ON os.step_id = o.step_id
                 INNER JOIN  legs ole
                 ON ole.leg_id = os.leg_id
                 INNER JOIN routes oro
                 ON oro.route_id = ole.route_id
                 WHERE r.route_id = oro.route_id
                 AND o.latitude BETWEEN ? AND ?
                 AND o.longitude BETWEEN ? AND ?
                 )', array($originBoxMinLatitude,
                           $originBoxMaxLatitude,
                           $originBoxMinLongitude,
                           $originBoxMaxLongitude));
        }
        // See if we need to add a where clause for the destination location
        if ($destinationLatitude != null && $destinationLongitude != null)
        {
            // Add the where clause that searchs for routes near the end
            // location. Need to add a bounding box where clause to sub clause
            // to improve performance
//            $q->andWhere('EXISTS (
//                 SELECT *,  MIN(DISTANCE(?, ?, d.latitude, d.longitude)) as end_distance
//                 FROM locations d
//                 INNER JOIN  steps ds
//                 ON ds.step_id = d.step_id
//                 INNER JOIN  legs dle
//                 ON dle.leg_id = ds.leg_id
//                 INNER JOIN routes dro
//                 ON dro.route_id = dle.route_id
//                 GROUP BY dro.route_id
//                 HAVING end_distance < ?
//                   AND r.route_id = dro.route_id
//                  )', array($destinationLatitude,
//                            $destinationLongitude,
//                            $distance));
            // Use bounding box search for now for performance
            $destinationBoundingBox = Locations::getBoundingBox($destinationLatitude, 
                                                                $destinationLongitude, 
                                                                $distance);
            $destinationBoxMinLatitude = $destinationBoundingBox['minLatitude'];
            $destinationBoxMaxLatitude = $destinationBoundingBox['maxLatitude'];
            $destinationBoxMinLongitude = $destinationBoundingBox['minLongitude'];
            $destinationBoxMaxLongitude = $destinationBoundingBox['maxLongitude'];
            
            $q->andWhere('EXISTS (
                 SELECT *
                 FROM locations d
                 INNER JOIN  steps ds
                 ON ds.step_id = d.step_id
                 INNER JOIN  legs dle
                 ON dle.leg_id = ds.leg_id
                 INNER JOIN routes dro
                 ON dro.route_id = dle.route_id
                 WHERE r.route_id = dro.route_id
                 AND d.latitude BETWEEN ? AND ?
                 AND d.longitude BETWEEN ? AND ?
                 )', array($destinationBoxMinLatitude,
                           $destinationBoxMaxLatitude,
                           $destinationBoxMinLongitude,
                           $destinationBoxMaxLongitude));
        }
        // See if we need to add a where clause for the date
        if ($date != null)
        {
            // Reformat the date to work with the database
            $date = date('Y-m-d', strtotime($date));
            $q = $q->andWhere('pa.start_date = ?', $date)
                   ->andWhere('pa.status_id != ?', RideStatuses::$statuses[RideStatuses::RIDE_DELETED])
                   ->andWhere('pa.status_id != ?', RideStatuses::$statuses[RideStatuses::RIDE_CLOSED]);
        }
        else
        {
            // Add the current rides filter to filter our rides from before today
            $q = $this->addCurrentRidesFilter($q);
        }
        
        // Order by the start date
        $q = $q->orderBy('pa.start_date');
        
        // ON p.route_id = r.route_id
        // Add the components to the query so the results get hydrated into
        // their proper objects
        $q->addComponent('pa', 'Passengers pa');
        $q->addComponent('r', 'pa.Routes r');
        $q->addComponent('pe', 'pa.People pe');
        $q->addComponent('pr', 'pe.Profiles pr');

        // Run the query and return the results
        return $q->execute();
    }
    
    /**
     * Finds potential passengers along a route
     * @param float $distance The distance to search for in miles
     * @param String $encodedPolyline The encoded polyline to search along
     * @param String $date The date to search on
     * @return Doctrine_Collection The matched passengers
     */
    public function getAlongRoute($distance, $encodedPolyline, $date)
    {
        // Get the list of all intermediate points
        $intermediatePoints = GeometryHelpers::decodePolylineToArray($encodedPolyline);
        
        // Keep an array of passengers that match
        $results = new Doctrine_Collection('Passengers');
        
        // We need to keep a list of passengers whose pick up and drop off
        // locations matched along the route
        $pickUpMatches = new Doctrine_Collection('Passengers');
        $dropOffMatches = new Doctrine_Collection('Passengers');

        // Build the array of points to be fed into the route boxer
	$latlngs = array();
        foreach ($intermediatePoints as $point)
        {
            $latlngs[] = new LatLng($point['lat'], $point['lon']);
        }
        // Get the routes origin point which will be used later
        $routeOrigin = $latlngs[0];
        
        // Build the route boxes to search within. Eventually this should
        // be replaced with a spatial database supporting OpenGIS like PostGIS
        $distanceInKilometers = $distance * 1.60934; 
        $routeBoxer = new RouteBoxer();
	$boxes = $routeBoxer->box($latlngs, $distanceInKilometers);
        
        // Loop through all of the boxes and get all origin points and 
        // destination points in the box
	foreach ($boxes as $box)
	{
            // Get the passengers who can be picked up in the box
            $pickUpPassengerMatches = Doctrine_Core::getTable('Passengers')->getPickUpPassengersInBox($box, $date);
            
            // Add the pick up passengers to the pick up matches list
            foreach ($pickUpPassengerMatches as $pickUpPassengerMatch) 
            {
                // Add the pick up passenger to the matches. This prevents duplicates.
                $pickUpMatches->add($pickUpPassengerMatch, $pickUpPassengerMatch->getPassengerId());
            }
            
            // Get the passengers who can be dropped off up in the box
            $dropOffPassengerMatches = Doctrine_Core::getTable('Passengers')->getDropOffPassengersInBox($box, $date);
            
            // Add the drop off passengers to the drop off matches list
            foreach($dropOffPassengerMatches as $dropOffPassengerMatch)
            {
                // Add the drop off passenger to the matches. This prevents duplicates.
                $dropOffMatches->add($dropOffPassengerMatch, $dropOffPassengerMatch->getPassengerId());
            }
	}
        
        // Decide which of the matches are true matches
        foreach ($pickUpMatches as $pickUpMatch)
        {
            $pickUpMatchId = $pickUpMatch->getPassengerId();
            
            // Passenger matches must exist in the pickup and dropoff lists
            if ($dropOffMatches->contains($pickUpMatchId))
            {
                // Filter to make sure the passenger is going in the same 
                // direction as the driver. The distance from the driver origin 
                // to the passenger pick up location must be less than the 
                // distance to the passenger drop off location
                $driverOriginLatitude = $routeOrigin->lat();
                $driverOriginLongitude = $routeOrigin->lng();
                $passengerPickUpLatitude = $pickUpMatch->getRoutes()->getOriginLatitude();
                $passengerPickUpLongitude = $pickUpMatch->getRoutes()->getOriginLongitude();
                $passengerDropOffLatitude = $pickUpMatch->getRoutes()->getDestinationLatitude();
                $passengerDropOffLongitude = $pickUpMatch->getRoutes()->getDestinationLongitude();
                if(GeometryHelpers::getDistanceBetweenPoints($driverOriginLatitude, $driverOriginLongitude, $passengerPickUpLatitude, $passengerPickUpLongitude)
                        < GeometryHelpers::getDistanceBetweenPoints($driverOriginLatitude, $driverOriginLongitude, $passengerDropOffLatitude, $passengerDropOffLongitude))
                {
                    // This is a real match! Add it to results.
                    $results->add($pickUpMatch);
                }
            }
        }
        
        return $results;
    }
    
    /**
     * Gets the passengers who need to be picked up in a bounding box
     * @param LatLngBounds $box The box to search in
     * @param String $date The date to search on
     * @return Doctrine_Collection The passengers who need picked up near a point
     */
    public function getPickUpPassengersInBox($box, $date = null)
    {
        $boxMinLatitude = $box->getSouthWest()->lat();
        $boxMaxLatitude = $box->getNorthEast()->lat();
        $boxMinLongitude = $box->getSouthWest()->lng();
        $boxMaxLongitude = $box->getNorthEast()->lng();
        
        $q = $this->createQuery('pa')
                ->innerJoin('pa.Routes r')
                ->where('r.origin_latitude BETWEEN ? AND ? ', array($boxMinLatitude, $boxMaxLatitude))
                ->andWhere('r.origin_longitude BETWEEN ? AND ? ', array($boxMinLongitude, $boxMaxLongitude));
                
        // See if we need to add a where clause for the date
        if ($date != null)
        {
            // Reformat the date to work with the database
            $date = date('Y-m-d', strtotime($date));
            $q = $q->andWhere('pa.start_date = ?', $date)
                   ->andWhere('pa.status_id != ?', RideStatuses::$statuses[RideStatuses::RIDE_DELETED])
                   ->andWhere('pa.status_id != ?', RideStatuses::$statuses[RideStatuses::RIDE_CLOSED]);
        }
        else
        {
            // Add the current rides filter to filter our rides from before today
            $q = $this->addCurrentRidesFilter($q);
        }
                
        return $q->execute();
    }
    
    /**
     * Gets the passengers who need to be dropped off in a bounding box
     * @param LatLngBounds $box The box to search in
     * @param String $date The date to search on
     * @return Doctrine_Collection The passengers who need dropped off up near a point
     */
    public function getDropOffPassengersInBox($box, $date = null)
    {
        $boxMinLatitude = $box->getSouthWest()->lat();
        $boxMaxLatitude = $box->getNorthEast()->lat();
        $boxMinLongitude = $box->getSouthWest()->lng();
        $boxMaxLongitude = $box->getNorthEast()->lng();
        
        $q = $this->createQuery('pa')
                ->innerJoin('pa.Routes r')
                ->where('r.destination_latitude BETWEEN ? AND ? ', array($boxMinLatitude, $boxMaxLatitude))
                ->andWhere('r.destination_longitude BETWEEN ? AND ? ', array($boxMinLongitude, $boxMaxLongitude));
                
        // See if we need to add a where clause for the date
        if ($date != null)
        {
            // Reformat the date to work with the database
            $date = date('Y-m-d', strtotime($date));
            $q = $q->andWhere('pa.start_date = ?', $date)
                   ->andWhere('pa.status_id != ?', RideStatuses::$statuses[RideStatuses::RIDE_DELETED])
                   ->andWhere('pa.status_id != ?', RideStatuses::$statuses[RideStatuses::RIDE_CLOSED]);
        }
        else
        {
            // Add the current rides filter to filter our rides from before today
            $q = $this->addCurrentRidesFilter($q);
        }
                
        return $q->execute();
    }
}