<?php

/**
 * Routes
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    RootlessMe
 * @subpackage model
 * @author     awilliams
 * @version    SVN: $Id: Builder.php 7691 2011-02-04 15:43:29Z jwage $
 */
class Routes extends BaseRoutes
{
    /**
     * Gets the origin location of the route
     * @return Locations The origin location
     */
    public function getOriginLocation()
    {
        $first_location = $this->getSortedLocationsQuery('ASC')
                               ->limit(1)
                               ->execute()
                               ->getFirst();

        return $first_location;
    }

    /**
     * Gets the destination location of the route
     * @return Locations The destination location
     */
    public function getDestinationLocation()
    {
        $last_location = $this->getSortedLocationsQuery('DESC')
                              ->limit(1)
                              ->execute()
                              ->getFirst();

        return $last_location;
    }

    /**
     * Creates and saves a route from a Google directions javascript api result 
     * string.
     * @param String $googleDirections The Google directions javascript api 
     * result string with the latitude and longitude keys replaced with "lat" 
     * and "lon".
     * @param String $originGeocode The Google geocode javascript api result
     * string for the origin with the latitude and longitude keys replaced
     * with "lat" and "lon"
     * @param String $destinationGeocode The Google geocode javascript api result
     * string for the destination with the latitude and longitude keys replaced
     * with "lat" and "lon"
     */
    public function createFromGoogleDirections($googleDirections = null, $originGeocode = null, $destinationGeocode = null)
    {
        // Need to increase the maximum memory limit to allow really long 
        // routes.
        ini_set('memory_limit', '256M');
        
        // Make sure the parameters are not null
        if ($googleDirections == null)
        {
            sfContext::getInstance()->getLogger()->err("googleDirections is null.");
            return;
        }
        if ($originGeocode == null)
        {
            sfContext::getInstance()->getLogger()->err("originGeocode is null.");
            return;
        }
        if ($destinationGeocode == null)
        {
            sfContext::getInstance()->getLogger()->err("destinationGeocode is null.");
            return;
        }

        // The directions should be in JSON format, so decode them
        $jRoute = json_decode($googleDirections, true);
        if (json_last_error() != JSON_ERROR_NONE)
        {
            sfContext::getInstance()->getLogger()->error("JSON last error: ".json_last_error());
            return;
        }
        $jOrigin = json_decode($originGeocode, true);
        if (json_last_error() != JSON_ERROR_NONE)
        {
            sfContext::getInstance()->getLogger()->error("JSON last error: ".json_last_error());
            return;
        }
        $jDestination = json_decode($destinationGeocode, true);
        if (json_last_error() != JSON_ERROR_NONE)
        {
            sfContext::getInstance()->getLogger()->error("JSON last error: ".json_last_error());
            return;
        }
        
        // Do this setting below for BIG-ASS runtime Doctrine systems... FFS!
        Doctrine_Manager::connection()->setAttribute(Doctrine_Core::ATTR_AUTO_FREE_QUERY_OBJECTS, true);

        // There can be multiple routes, for now just use the first
        $routeNumber = 0;
        $route_data = $jRoute["routes"][$routeNumber];
        $summary = $route_data["summary"];
        $this->setSummary($summary);
        $copyright = $route_data["copyrights"];
        $this->setCopyright($copyright);
        $polyline = $route_data["overview_polyline"]["points"];
        $this->setEncodedPolyline($polyline);

        // Increment the sequence order for all detail levels at
        // a route level, instead of nesting. This means the locations
        // can be sorted without joining up to the route level
        $legNumber = 0;
        $stepNumber = 0;
        $locationNumber = 0;

        // Get the leg count
        $legsCount = count($jRoute["routes"][$routeNumber]["legs"]);

        // Get the origin and destination data from the data parameters
        foreach ($jOrigin['address_components'] as $addressComponent)
        {
            // City
            if (in_array("locality",$addressComponent["types"]))
            {
                $this->setOriginCity($addressComponent["long_name"]);
            }
            // State
            if (in_array("administrative_area_level_1",$addressComponent["types"]))
            {
                $this->setOriginState($addressComponent["short_name"]);
            }
        }
        foreach ($jDestination['address_components'] as $addressComponent)
        {
            // City
            if (in_array("locality",$addressComponent["types"]))
            {
                $this->setDestinationCity($addressComponent["long_name"]);
            }
            // State
            if (in_array("administrative_area_level_1",$addressComponent["types"]))
            {
                $this->setDestinationState($addressComponent["short_name"]);
            }
        }

        // Get the origin and destination data from the legs
        $origin_leg_data = $jRoute["routes"][$routeNumber]["legs"][0];
        $this->setOriginAddress($origin_leg_data["start_address"]);
        $this->setOriginLatitude($origin_leg_data["start_location"]['lat']);
        $this->setOriginLongitude($origin_leg_data["start_location"]['lon']);
        $destination_leg_data = $jRoute["routes"][$routeNumber]["legs"][$legsCount-1];
        $this->setDestinationAddress($destination_leg_data["end_address"]);
        $this->setDestinationLatitude($destination_leg_data["end_location"]['lat']);
        $this->setDestinationLongitude($destination_leg_data["end_location"]['lon']);
        $route_distance = 0;
        $route_duration = 0;

        // Create the legs
        for ($currentLeg = 0 ; $currentLeg < $legsCount ; $currentLeg++ )
        {
            $leg_data = $jRoute["routes"][$routeNumber]["legs"][$currentLeg];
            $leg = new Legs();
            $leg->setSequenceOrder($legNumber);
            $leg->setRoutes($this);
            $leg->save();

            // Update the route distance and duration using the leg data
            $route_distance += $leg_data["distance"]["value"];
            $route_duration += $leg_data["duration"]["value"];

            // Create the steps
            $stepsCount = count($leg_data["steps"]);
            for ($currentStep = 0 ; $currentStep < $stepsCount ; $currentStep++ )
            {
                // Leave in this debug statement while I am debugging
                // performance issues
                sfContext::getInstance()->getLogger()->debug( 'Saving step '.$currentStep.'of'.$stepsCount );
                  
                  
                $step_data = $leg_data["steps"][$currentStep];
                $step = new Steps();
                $step->setInstructions($step_data["instructions"]);
                $step->setDistance($step_data["distance"]["value"]);
                $step->setDuration($step_data["duration"]["value"]);
                $step->setEncodedPolyline($step_data["polyline"]["points"]);
                $step->setSequenceOrder($stepNumber);
                $step->setLegs($leg);
                $step->save();
                
                // Get the step_id
                $stepId = $step->getStepId();

                $locationsCount = count($step_data["path"]);
                
                // Use a bulk insert class to insert the locations to improve
                // performance. Before bulk insert, only trips of <4 hours 
                // could be saved.
                $bulkInsertQueryGenerator = new LocationsBulkQuery();
                
                // Create the locations
                for ($currentLocation = 0 ; $currentLocation < $locationsCount ; $currentLocation++)
                {
                    $location_data = $step_data["path"][$currentLocation];
                    $location = new Locations();
                    
                    // Use the lat and lon keys that were replaced by the 
                    // javascript                    
                    // Using Arrays instead of the Locations object
                    // for performance reasons
                    $location = Array('latitude' => $location_data['lat'],
                                      'longitude' => $location_data['lon'], 
                                      'sequence_order' => $locationNumber,
                                      'step_id' => $stepId);
                    
                    // Add the location to the bulk query generator
                    $bulkInsertQueryGenerator->Add($location);

                    // Increment the sequence counter
                    $locationNumber++;
                }
                
                // Generate the bulk query and execute it
                $bulkQuery = $bulkInsertQueryGenerator->ToInsertQueryString();
                $q = Doctrine_Manager::getInstance()->getCurrentConnection();
                $result = $q->execute($bulkQuery);
                
                // Free the query resources
                $q->clear();
                unset($bulkQuery);
                unset($bulkInsertQueryGenerator);

                // Increment the sequence counter
                $stepNumber++;
            }
            // Increment the sequence counter
            $legNumber++;
        }

        // Set the distance and duration
        $this->setDistance($route_distance);
        $this->setDuration($route_duration);

        // Save the route
        $this->save();

        // Update the origin and destination locations to use the
        // geocoded information
        $origin = $this->getOriginLocation();
        $origin->createFromGoogleGeocode($originGeocode);
        $destination = $this->getDestinationLocation();
        $destination->createFromGoogleGeocode($destinationGeocode);
    }

    /**
     * Gets a query that returns all locations associated with the route, in
     * a sorted order.
     * @param string $orderDirection The sort order. 'ASC' and 'DESC' are
     * supported. All others are ignored.
     * @return Doctrine_Query The query that gets the sorted locations
     */
    private function getSortedLocationsQuery($orderDirection)
    {
        // Query should look like
        // select *
        // from locations l
        // inner join steps s
        //   on l.step_id = s.step_id
        // inner join legs le
        //   on s.leg_id = le.leg_id
        // inner join routes r
        //   on le.route_id = r.route_id
        // where r.route_id = 1
        // order by le.sequence_order asc,
        //          s.sequence_order asc,
        //          l.sequence_order asc;
        $q = Doctrine_Query::create()
                ->from('Locations l')
                ->innerJoin('l.Steps s')
                ->innerJoin('s.Legs le')
                ->innerJoin('le.Routes r')
                ->where('r.route_id = ?', $this->getRouteId());

        // Workaround because I cannot figure out how to pass in the order
        // direction from the parameter
        if ($orderDirection == 'ASC')
        {
            $q->orderBy('le.sequence_order ASC, s.sequence_order ASC, l.sequence_order ASC');
        }
        elseif ($orderDirection == 'DESC')
        {
            $q->orderBy('le.sequence_order DESC, s.sequence_order DESC, l.sequence_order DESC');
        }

        return $q;
    }

    /**
     * Gets the origin of the route as a string
     * @param Boolean $getFullAddress Whether to get the full address or just
     * the city state string
     * @return String The origin as a string
     */
    public function getOriginString($getFullAddress = false)
    {
        $locationString = '';

        if ($getFullAddress)
        {
            $locationString = $this->getOriginAddress();
        }
        else
        {
            // Use the abreviated form of the string
            $locationString = Locations::createCityStateString($this->getOriginCity(), $this->getOriginState());
        }

        return $locationString;
    }

    /**
     * Gets the destination of the route as a string
     * @param Boolean $getFullAddress Whether to get the full address or just
     * the city state string
     * @return String The destination as a string
     */
    public function getDestinationString($getFullAddress = false)
    {
        $locationString = '';

        if ($getFullAddress)
        {
            $locationString = $this->getDestinationAddress();
        }
        else
        {
            // Use the abreviated form of the string
            $locationString = Locations::createCityStateString($this->getDestinationCity(), $this->getDestinationState());
        }

        return $locationString;
    }
    
    /**
     * Gets the locations contained in the route
     * @return Array The locations in an array
     */
    public function getLocationsInRoute()
    {
        return Doctrine_Core::getTable('Locations')->getLocationsInRoute($this->getRouteId());
    }
}